import { describe, it, expect, beforeEach, afterEach } from "vitest";
import { mkdirSync, rmSync, readFileSync, writeFileSync } from "node:fs";
import { join } from "node:path";
import { tmpdir } from "node:os";
import {
  generateSkillMdForDirectory,
  isAutoGenerated,
  parseModule,
  generateSkillMd,
  type ModuleInfo,
} from "./generator.js";

describe("skillmd generator", () => {
  describe("isAutoGenerated", () => {
    const testDir = join(tmpdir(), "vibe-cli-skillmd-test-" + Date.now());

    beforeEach(() => {
      mkdirSync(testDir, { recursive: true });
    });

    afterEach(() => {
      rmSync(testDir, { recursive: true, force: true });
    });

    it("returns null when SKILL.md does not exist", () => {
      const result = isAutoGenerated(join(testDir, "SKILL.md"));
      expect(result).toBeNull();
    });

    it("returns true when SKILL.md has auto-gen header", () => {
      const skillMdPath = join(testDir, "SKILL.md");
      writeFileSync(
        skillMdPath,
        "<!-- Auto-generated by VoR -->\n\n# Test Module\n",
        "utf-8",
      );
      const result = isAutoGenerated(skillMdPath);
      expect(result).toBe(true);
    });

    it("returns false when SKILL.md exists but was manually edited", () => {
      const skillMdPath = join(testDir, "SKILL.md");
      writeFileSync(skillMdPath, "# Test Module\n\nManual content\n", "utf-8");
      const result = isAutoGenerated(skillMdPath);
      expect(result).toBe(false);
    });
  });

  describe("parseModule", () => {
    const testDir = join(tmpdir(), "vibe-cli-skillmd-parse-" + Date.now());

    beforeEach(() => {
      mkdirSync(testDir, { recursive: true });
    });

    afterEach(() => {
      rmSync(testDir, { recursive: true, force: true });
    });

    it("extracts function exports", () => {
      const filePath = join(testDir, "service.ts");
      writeFileSync(
        filePath,
        `export async function findAll(): Promise<User[]> {
          return [];
        }
        
        export function findById(id: string): Promise<User | null> {
          return null;
        }`,
        "utf-8",
      );

      const moduleInfo = parseModule(filePath);
      expect(moduleInfo.exports).toHaveLength(2);
      expect(moduleInfo.exports[0].name).toBe("findAll");
      expect(moduleInfo.exports[0].type).toBe("function");
      expect(moduleInfo.exports[1].name).toBe("findById");
    });

    it("extracts type exports", () => {
      const filePath = join(testDir, "types.ts");
      writeFileSync(
        filePath,
        `export type User = {
          id: string;
          name: string;
        };
        
        export interface CreateUser {
          name: string;
        }`,
        "utf-8",
      );

      const moduleInfo = parseModule(filePath);
      expect(moduleInfo.types).toHaveLength(2);
      expect(moduleInfo.types[0].name).toBe("User");
      expect(moduleInfo.types[1].name).toBe("CreateUser");
    });

    it("extracts tRPC routes from controller", () => {
      const filePath = join(testDir, "controller.ts");
      writeFileSync(
        filePath,
        `import { router, publicProcedure } from "@vibeonrails/core/api";
        
        export const userRouter = router({
          list: publicProcedure.query(async () => {
            return [];
          }),
          create: publicProcedure
            .input(z.object({ name: z.string() }))
            .mutation(async ({ input }) => {
              return input;
            }),
        });`,
        "utf-8",
      );

      const moduleInfo = parseModule(filePath);
      expect(moduleInfo.routes).toBeDefined();
      expect(moduleInfo.routes).toHaveLength(2);
      expect(moduleInfo.routes![0].name).toBe("list");
      expect(moduleInfo.routes![0].type).toBe("query");
      expect(moduleInfo.routes![1].name).toBe("create");
      expect(moduleInfo.routes![1].type).toBe("mutation");
    });

    it("extracts description from JSDoc comment", () => {
      const filePath = join(testDir, "service.ts");
      writeFileSync(
        filePath,
        `/**
         * User service handles all user-related business logic.
         */
        export function findAll() {}`,
        "utf-8",
      );

      const moduleInfo = parseModule(filePath);
      expect(moduleInfo.description).toContain("User service");
    });
  });

  describe("generateSkillMd", () => {
    it("generates SKILL.md with auto-gen header", () => {
      const moduleInfo: ModuleInfo = {
        name: "UserService",
        description: "Handles user operations",
        exports: [
          {
            name: "findAll",
            type: "function",
            signature: "export async function findAll(): Promise<User[]>",
          },
        ],
        types: [
          {
            name: "User",
            definition: "export type User = { id: string; name: string }",
          },
        ],
        routes: [
          {
            name: "list",
            type: "query",
          },
        ],
      };

      const content = generateSkillMd(moduleInfo);
      expect(content).toContain("<!-- Auto-generated by VoR -->");
      expect(content).toContain("# UserService");
      expect(content).toContain("## Purpose");
      expect(content).toContain("Handles user operations");
      expect(content).toContain("## Exports");
      expect(content).toContain("findAll");
      expect(content).toContain("## Types");
      expect(content).toContain("User");
      expect(content).toContain("## API Routes");
      expect(content).toContain("list");
      expect(content).toContain("## Usage Examples");
    });

    it("generates minimal SKILL.md when only exports are present", () => {
      const moduleInfo: ModuleInfo = {
        name: "Utils",
        exports: [
          {
            name: "formatDate",
            type: "function",
            signature: "export function formatDate(date: Date): string",
          },
        ],
        types: [],
      };

      const content = generateSkillMd(moduleInfo);
      expect(content).toContain("# Utils");
      expect(content).toContain("formatDate");
      expect(content).not.toContain("## Types");
      expect(content).not.toContain("## API Routes");
    });
  });

  describe("generateSkillMdForDirectory", () => {
    const testDir = join(tmpdir(), "vibe-cli-skillmd-dir-" + Date.now());

    beforeEach(() => {
      mkdirSync(testDir, { recursive: true });
    });

    afterEach(() => {
      rmSync(testDir, { recursive: true, force: true });
    });

    it("generates SKILL.md for directory with TypeScript files", () => {
      writeFileSync(
        join(testDir, "service.ts"),
        `export async function findAll(): Promise<User[]> {
          return [];
        }`,
        "utf-8",
      );

      writeFileSync(
        join(testDir, "types.ts"),
        `export type User = {
          id: string;
          name: string;
        };`,
        "utf-8",
      );

      generateSkillMdForDirectory(testDir);

      const skillMdPath = join(testDir, "SKILL.md");
      expect(readFileSync(skillMdPath, "utf-8")).toContain(
        "<!-- Auto-generated by VoR -->",
      );
      expect(readFileSync(skillMdPath, "utf-8")).toContain("findAll");
      expect(readFileSync(skillMdPath, "utf-8")).toContain("User");
    });

    it("skips manually edited SKILL.md files", () => {
      const skillMdPath = join(testDir, "SKILL.md");
      writeFileSync(
        skillMdPath,
        "# Manual SKILL.md\n\nCustom content\n",
        "utf-8",
      );

      writeFileSync(
        join(testDir, "service.ts"),
        `export function test() {}`,
        "utf-8",
      );

      generateSkillMdForDirectory(testDir);

      // Should not have been overwritten
      const content = readFileSync(skillMdPath, "utf-8");
      expect(content).toBe("# Manual SKILL.md\n\nCustom content\n");
      expect(content).not.toContain("<!-- Auto-generated by VoR -->");
    });

    it("overwrites manually edited SKILL.md when force is true", () => {
      const skillMdPath = join(testDir, "SKILL.md");
      writeFileSync(
        skillMdPath,
        "# Manual SKILL.md\n\nCustom content\n",
        "utf-8",
      );

      writeFileSync(
        join(testDir, "service.ts"),
        `export function test() {}`,
        "utf-8",
      );

      generateSkillMdForDirectory(testDir, { force: true });

      const content = readFileSync(skillMdPath, "utf-8");
      expect(content).toContain("<!-- Auto-generated by VoR -->");
      expect(content).toContain("test");
    });

    it("skips test files", () => {
      writeFileSync(
        join(testDir, "service.ts"),
        `export function findAll() {}`,
        "utf-8",
      );

      writeFileSync(
        join(testDir, "service.test.ts"),
        `export function testHelper() {}`,
        "utf-8",
      );

      generateSkillMdForDirectory(testDir);

      const content = readFileSync(join(testDir, "SKILL.md"), "utf-8");
      expect(content).toContain("findAll");
      expect(content).not.toContain("testHelper");
    });

    it("does nothing when directory has no TypeScript files", () => {
      writeFileSync(join(testDir, "README.md"), "# Readme\n", "utf-8");

      generateSkillMdForDirectory(testDir);

      const skillMdPath = join(testDir, "SKILL.md");
      try {
        readFileSync(skillMdPath, "utf-8");
        expect.fail("SKILL.md should not have been created");
      } catch {
        // Expected - file doesn't exist
      }
    });

    it("combines exports from multiple files", () => {
      writeFileSync(
        join(testDir, "service.ts"),
        `export function findAll() {}`,
        "utf-8",
      );

      writeFileSync(
        join(testDir, "controller.ts"),
        `export function create() {}`,
        "utf-8",
      );

      generateSkillMdForDirectory(testDir);

      const content = readFileSync(join(testDir, "SKILL.md"), "utf-8");
      expect(content).toContain("findAll");
      expect(content).toContain("create");
    });
  });
});
