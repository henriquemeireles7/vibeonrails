import { readdirSync, readFileSync, statSync, writeFileSync } from "node:fs";
import { join, basename, dirname, extname } from "node:path";

const AUTO_GEN_HEADER = "<!-- Auto-generated by VoR -->";

export interface ExportInfo {
  name: string;
  type: "function" | "type" | "interface" | "class" | "const" | "variable";
  signature?: string;
  description?: string;
}

export interface TypeInfo {
  name: string;
  definition: string;
}

export interface ModuleInfo {
  name: string;
  description?: string;
  exports: ExportInfo[];
  types: TypeInfo[];
  routes?: Array<{
    name: string;
    type: "query" | "mutation";
    input?: string;
    description?: string;
  }>;
}

/**
 * Check if a SKILL.md file exists and was auto-generated.
 * Returns true if it exists and has the auto-gen header, false if it doesn't exist,
 * and throws if it exists but was manually edited (missing header).
 */
export function isAutoGenerated(skillMdPath: string): boolean | null {
  try {
    const content = readFileSync(skillMdPath, "utf-8");
    return content.trimStart().startsWith(AUTO_GEN_HEADER);
  } catch {
    return null; // File doesn't exist
  }
}

/**
 * Extract function signature from a function declaration or arrow function.
 */
function extractFunctionSignature(
  content: string,
  name: string,
): string | undefined {
  // Match function declarations: export function name(...) {...}
  const funcDeclRegex = new RegExp(
    `export\\s+(async\\s+)?function\\s+${name}\\s*\\([^)]*\\)\\s*(:\\s*[^{]+)?`,
    "s",
  );
  const funcMatch = content.match(funcDeclRegex);
  if (funcMatch) {
    return funcMatch[0]
      .replace(/\s+/g, " ")
      .replace(/\s*\{.*$/, "")
      .trim();
  }

  // Match arrow functions: export const name = (...) => ...
  const arrowRegex = new RegExp(
    `export\\s+const\\s+${name}\\s*=\\s*(async\\s*)?\\([^)]*\\)\\s*(:\\s*[^=]+)?\\s*=>`,
    "s",
  );
  const arrowMatch = content.match(arrowRegex);
  if (arrowMatch) {
    return `export const ${name} = ${arrowMatch[0]
      .replace(/^export\s+const\s+\w+\s*=\s*/, "")
      .replace(/\s+/g, " ")
      .trim()}`;
  }

  return undefined;
}

/**
 * Extract type/interface definition.
 */
function extractTypeDefinition(content: string, name: string): string | undefined {
  // Match type aliases: export type Name = ...
  const typeRegex = new RegExp(
    `export\\s+type\\s+${name}\\s*=\\s*[^;]+;`,
    "s",
  );
  const typeMatch = content.match(typeRegex);
  if (typeMatch) {
    return typeMatch[0].replace(/\s+/g, " ").trim();
  }

  // Match interfaces: export interface Name { ... }
  const interfaceRegex = new RegExp(
    `export\\s+interface\\s+${name}\\s*\\{[^}]*\\}`,
    "s",
  );
  const interfaceMatch = content.match(interfaceRegex);
  if (interfaceMatch) {
    return interfaceMatch[0].replace(/\s+/g, " ").trim();
  }

  return undefined;
}

/**
 * Extract exports from a TypeScript file.
 */
function extractExports(content: string): ExportInfo[] {
  const exports: ExportInfo[] = [];

  // Match export function declarations
  const funcExports = content.matchAll(
    /export\s+(async\s+)?function\s+(\w+)/g,
  );
  for (const match of funcExports) {
    const name = match[2];
    const signature = extractFunctionSignature(content, name);
    exports.push({
      name,
      type: "function",
      signature,
    });
  }

  // Match export const declarations (functions or variables)
  const constExports = content.matchAll(/export\s+const\s+(\w+)/g);
  for (const match of constExports) {
    const name = match[1];
    const signature = extractFunctionSignature(content, name);
    exports.push({
      name,
      type: signature ? "function" : "const",
      signature,
    });
  }

  // Match export type declarations
  const typeExports = content.matchAll(/export\s+type\s+(\w+)/g);
  for (const match of typeExports) {
    const name = match[1];
    const definition = extractTypeDefinition(content, name);
    exports.push({
      name,
      type: "type",
      signature: definition,
    });
  }

  // Match export interface declarations
  const interfaceExports = content.matchAll(/export\s+interface\s+(\w+)/g);
  for (const match of interfaceExports) {
    const name = match[1];
    const definition = extractTypeDefinition(content, name);
    exports.push({
      name,
      type: "interface",
      signature: definition,
    });
  }

  // Match export class declarations
  const classExports = content.matchAll(/export\s+class\s+(\w+)/g);
  for (const match of classExports) {
    const name = match[1];
    exports.push({
      name,
      type: "class",
    });
  }

  return exports;
}

/**
 * Extract types/interfaces from a TypeScript file.
 */
function extractTypes(content: string): TypeInfo[] {
  const types: TypeInfo[] = [];

  // Match type aliases
  const typeMatches = content.matchAll(/export\s+type\s+(\w+)\s*=\s*([^;]+);/gs);
  for (const match of typeMatches) {
    types.push({
      name: match[1],
      definition: match[0].replace(/\s+/g, " ").trim(),
    });
  }

  // Match interfaces
  const interfaceMatches = content.matchAll(
    /export\s+interface\s+(\w+)\s*\{[^}]*\}/gs,
  );
  for (const match of interfaceMatches) {
    types.push({
      name: match[1],
      definition: match[0].replace(/\s+/g, " ").trim(),
    });
  }

  return types;
}

/**
 * Extract tRPC routes from a controller file.
 */
function extractRoutes(content: string): Array<{
  name: string;
  type: "query" | "mutation";
  input?: string;
  description?: string;
}> {
  const routes: Array<{
    name: string;
    type: "query" | "mutation";
    input?: string;
    description?: string;
  }> = [];

  // Match router definitions: name: publicProcedure.query(...) or .mutation(...)
  // Handle both single-line and multi-line patterns
  // First, find all route names that are followed by publicProcedure or protectedProcedure
  const routeNameRegex = /(\w+):\s*(publicProcedure|protectedProcedure)/g;
  const routeMatches = content.matchAll(routeNameRegex);

  for (const routeMatch of routeMatches) {
    const name = routeMatch[1];
    
    // Find the query or mutation call after the procedure (may be on same or next line)
    // Look for .query( or .mutation( after the procedure declaration, allowing for .input() calls in between
    const routeContent = content.substring(routeMatch.index!);
    const queryMatch = routeContent.match(/\.(query|mutation)\s*\(/);
    if (!queryMatch) continue;
    
    const type = queryMatch[1] as "query" | "mutation";

    // Try to extract input schema name (handle multi-line)
    // Look for .input(...) between the procedure and query/mutation
    let input: string | undefined;
    const inputPattern = new RegExp(
      `${name}:\\s*[\\s\\S]*?\\.input\\(([^)]+)\\)[\\s\\S]*?\\.(?:query|mutation)`,
      "s",
    );
    const inputMatch = routeContent.match(inputPattern);
    if (inputMatch) {
      input = inputMatch[1].trim();
    }

    routes.push({
      name,
      type,
      input,
    });
  }

  return routes;
}

/**
 * Parse a TypeScript file and extract module information.
 */
export function parseModule(filePath: string): ModuleInfo {
  const content = readFileSync(filePath, "utf-8");
  const fileName = basename(filePath, extname(filePath));
  const dirName = basename(dirname(filePath));

  // Derive module name from directory or file name
  const moduleName = dirName !== "src" ? dirName : fileName;

  const exports = extractExports(content);
  const types = extractTypes(content);
  const routes = extractRoutes(content);

  // Try to extract description from JSDoc comment at the top
  const jsdocMatch = content.match(/\/\*\*\s*\n\s*\*\s*(.+?)\s*\n\s*\*\//s);
  const description = jsdocMatch ? jsdocMatch[1].trim() : undefined;

  return {
    name: moduleName,
    description,
    exports,
    types,
    routes: routes.length > 0 ? routes : undefined,
  };
}

/**
 * Generate SKILL.md content from module information.
 */
export function generateSkillMd(moduleInfo: ModuleInfo): string {
  const lines: string[] = [];

  lines.push(AUTO_GEN_HEADER);
  lines.push("");
  lines.push(`# ${moduleInfo.name}`);
  lines.push("");

  if (moduleInfo.description) {
    lines.push("## Purpose");
    lines.push("");
    lines.push(moduleInfo.description);
    lines.push("");
  }

  if (moduleInfo.exports.length > 0) {
    lines.push("## Exports");
    lines.push("");

    for (const exp of moduleInfo.exports) {
      if (exp.signature) {
        lines.push(`### ${exp.name}`);
        lines.push("");
        lines.push("```typescript");
        lines.push(exp.signature);
        lines.push("```");
        lines.push("");
      } else {
        lines.push(`- \`${exp.name}\` (${exp.type})`);
      }
    }
    lines.push("");
  }

  if (moduleInfo.types.length > 0) {
    lines.push("## Types");
    lines.push("");

    for (const type of moduleInfo.types) {
      lines.push(`### ${type.name}`);
      lines.push("");
      lines.push("```typescript");
      lines.push(type.definition);
      lines.push("```");
      lines.push("");
    }
  }

  if (moduleInfo.routes && moduleInfo.routes.length > 0) {
    lines.push("## API Routes");
    lines.push("");
    lines.push("| Route | Type | Input | Description |");
    lines.push("|-------|------|-------|-------------|");

    for (const route of moduleInfo.routes) {
      const input = route.input || "—";
      const desc = route.description || "—";
      lines.push(`| \`${route.name}\` | ${route.type} | \`${input}\` | ${desc} |`);
    }
    lines.push("");
  }

  lines.push("## Usage Examples");
  lines.push("");
  lines.push("<!-- TODO: Add usage examples -->");
  lines.push("");

  return lines.join("\n");
}

/**
 * Generate SKILL.md for a directory containing TypeScript files.
 * Scans all .ts files in the directory and generates a combined SKILL.md.
 */
export function generateSkillMdForDirectory(
  directory: string,
  options?: { force?: boolean },
): void {
  const skillMdPath = join(directory, "SKILL.md");

  // Check if SKILL.md exists and was manually edited
  const autoGenStatus = isAutoGenerated(skillMdPath);
  if (autoGenStatus === false && !options?.force) {
    // File exists but was manually edited - skip it
    return;
  }

  const entries = readdirSync(directory);
  const tsFiles = entries
    .filter((entry) => {
      const fullPath = join(directory, entry);
      const stat = statSync(fullPath);
      return stat.isFile() && entry.endsWith(".ts") && !entry.endsWith(".test.ts");
    })
    .map((entry) => join(directory, entry));

  if (tsFiles.length === 0) {
    return; // No TypeScript files to process
  }

  // Parse all TypeScript files and combine their exports/types
  const allExports: ExportInfo[] = [];
  const allTypes: TypeInfo[] = [];
  const allRoutes: Array<{
    name: string;
    type: "query" | "mutation";
    input?: string;
    description?: string;
  }> = [];

  const moduleName = basename(directory);
  let description: string | undefined;

  for (const filePath of tsFiles) {
    const moduleInfo = parseModule(filePath);
    allExports.push(...moduleInfo.exports);
    allTypes.push(...moduleInfo.types);
    if (moduleInfo.routes) {
      allRoutes.push(...moduleInfo.routes);
    }
    if (moduleInfo.description && !description) {
      description = moduleInfo.description;
    }
  }

  const combinedModuleInfo: ModuleInfo = {
    name: moduleName,
    description,
    exports: allExports,
    types: allTypes,
    routes: allRoutes.length > 0 ? allRoutes : undefined,
  };

  const skillMdContent = generateSkillMd(combinedModuleInfo);
  writeFileSync(skillMdPath, skillMdContent, "utf-8");
}
